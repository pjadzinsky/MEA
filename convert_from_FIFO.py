import meaRecording
from shutil import copyfile
import numpy as np
import struct
import matplotlib.pyplot as plt
import pdb
import sys

def interleaved_to_chunk(header_in, FIFO_in, file_out):
    '''
    FIFO_in is the name of a file generated by Igor's FIFO directly.
    The file has a header of length 304 + 76 * length(self.whichChan) and then
    Data starts. Data is in interleaved format. One sample for each channel is 
    stored, then the 2nd for each channel, the 3rd and so forth.
    
    inputs:
    -------
        header_in:  file with our header
        FIFO_in:    igor's output with their header and data
        file_out:   string with the name of the file to be generated by this script
    
    output:
    ------
        generates a file named file_out
    '''
    FIFO_HEADER_FIX_BYTES = 304
    FIFO_HEADER_BYTES_PER_CHANNEL = 76
    format_string = 'int16'     # not really important, anything that is 2 bytes will work

    # read header to extract some needed variaeles
    header = meaRecording.MEA(header_in)
    samples_per_channel = header.blockSize      # samples per channel per block, not in the whole recording
    channelsN = header.numberOfChannels
    num_of_blocks = int(np.ceil(header.nscans/samples_per_channel))
    bytes_per_sample = 2        # data is recorded as int16 (Big Endian, signed int, 2 bytes)
    block_size = samples_per_channel*channelsN*bytes_per_sample     # total number of bytes in one block taking all channels into account
    header.close()

    # copy header to file_out
    copyfile(header_in, file_out)

    # read blocks from FIFO and skip header
    fifo = open(FIFO_in, 'rb')
    fifo.seek(FIFO_HEADER_FIX_BYTES + header.numberOfChannels * FIFO_HEADER_BYTES_PER_CHANNEL)
    
    # open output file, header is already written, use 'append' mode
    output = open(file_out, 'ab')

    pdb.set_trace()
    for i in range(num_of_blocks):
        data_one_block = fifo.read(block_size)

        # make sure 'data_one_block' has the right number of points before reshaping it
        if (len(data_one_block) != block_size):
            # last read from file, not enough sample to fill a blockSize
            # write as much data as possible such that all channels get the same amount of data
            samples_per_channel = len(data_one_block)//header.numberOfChannels//bytes_per_sample
            last_block_size = samples_per_channel*header.numberOfChannels*bytes_per_sample
            data_one_block = data_one_block[:last_block_size]

        # write data_one_block to output file but after reshaping it
        data_reshaped = np.fromstring(data_one_block, dtype=format_string).reshape(channelsN,2*samples_per_channel, order='F')

        # print first PD sample from data_one_block and data_reshaped
        print(data_one_block[:2])
        print(data_reshaped[0,:2].astype('S'), data_reshaped[0,:2])
        data_reshaped.tofile(output)

    # close both output and FIFO files, we are done
    fifo.close()
    output.close()
    
def plot_PD(file_out)
    # read ch0 from file_out and display it, try reading 10s
    test = meaRecording.MEA(file_out)
    ch0 = test.getChannel(0,10)
    plt.plot(ch0)
    plt.show()

if __name__=='__main__':
    if len(sys.argv) == 0 or len(sys.argv) > 3:
        error_string = """
        This function takes either one argument (prefix) and assumes prefix.bin and prefix_FIFO
        or it can take two positional arguments: header_in and FIFO_in
        try:
            python convert_from_FIFO.py prefix
            python convert_from_FIFO.py header_file FIFO_file
        """
        raise ValueError(error_string)

    if len(sys.argv) == 2:
        header_in = sys.argv[1] + '.bin'
        FIFO_in = sys.argv[1] + '_FIFO'
        file_out = sys.argv[1]
    else:
        header_in = sys.argv[1]
        FIFO_in = sys.argv[2]
        file_out = sys.argv[1].rstrip('.bin')
    
    import time
    t1 = time.time()
    interleaved_to_chunk(header_in, FIFO_in, file_out)
    print(time.time()-t1)
